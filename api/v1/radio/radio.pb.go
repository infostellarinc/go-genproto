// Code generated by protoc-gen-go. DO NOT EDIT.
// source: stellarstation/api/v1/radio/radio.proto

package radio

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Type of modulation. Modulation is the process of converting binary data (0's and 1's) to
// an analog wave for use in radio communication.
type Modulation int32

const (
	// Frequency Shift Keying. https://en.wikipedia.org/wiki/Frequency-shift_keying
	Modulation_FSK Modulation = 0
	// Audio Frequency Shift Keying. https://en.wikipedia.org/wiki/Frequency-shift_keying#Audio_FSK
	Modulation_AFSK Modulation = 1
	// Binary Phase Shift Keying. https://en.wikipedia.org/wiki/Phase-shift_keying#Binary_phase-shift_keying_(BPSK)
	Modulation_BPSK Modulation = 2
	// Multiple Frequency Shift Keying. https://en.wikipedia.org/wiki/Multiple_frequency-shift_keying
	Modulation_MFSK Modulation = 3
	// Quadrature Phase Shift Keying. https://en.wikipedia.org/wiki/Phase-shift_keying#Quadrature_phase-shift_keying_(QPSK)
	Modulation_QPSK Modulation = 4
	// 8-Phase Shift Keying. https://en.wikipedia.org/wiki/Phase-shift_keying
	Modulation_PSK8 Modulation = 5
	// 16-Phase Shift Keying. https://en.wikipedia.org/wiki/Phase-shift_keying
	Modulation_PSK16 Modulation = 6
	// 32-Phase Shift Keying. https://en.wikipedia.org/wiki/Phase-shift_keying
	Modulation_PSK32 Modulation = 7
	// 64-Phase Shift Keying. https://en.wikipedia.org/wiki/Phase-shift_keying
	Modulation_PSK64 Modulation = 8
	// 128-Phase Shift Keying. https://en.wikipedia.org/wiki/Phase-shift_keying
	Modulation_PSK128 Modulation = 9
	// 256-Phase Shift Keying. https://en.wikipedia.org/wiki/Phase-shift_keying
	Modulation_PSK256 Modulation = 10
	// Offset Quadrature Phase Shift Keying. https://en.wikipedia.org/wiki/Phase-shift_keying#Offset_QPSK_(OQPSK)
	Modulation_OQPSK Modulation = 11
	// 8-Phase Amplitude Modulation. https://en.wikipedia.org/wiki/Quadrature_amplitude_modulation
	Modulation_QAM8 Modulation = 12
	// 16-Phase Amplitude Modulation. https://en.wikipedia.org/wiki/Quadrature_amplitude_modulation
	Modulation_QAM16 Modulation = 13
	// 32-Phase Amplitude Modulation. https://en.wikipedia.org/wiki/Quadrature_amplitude_modulation
	Modulation_QAM32 Modulation = 14
	// 64-Phase Amplitude Modulation. https://en.wikipedia.org/wiki/Quadrature_amplitude_modulation
	Modulation_QAM64 Modulation = 15
	// 128-Phase Amplitude Modulation. https://en.wikipedia.org/wiki/Quadrature_amplitude_modulation
	Modulation_QAM128 Modulation = 16
	// 256-Phase Amplitude Modulation. https://en.wikipedia.org/wiki/Quadrature_amplitude_modulation
	Modulation_QAM256 Modulation = 17
	// Minimum Shift Keying. https://en.wikipedia.org/wiki/Minimum-shift_keying
	Modulation_MSK Modulation = 18
	// Gaussian Minimum Shift Keying. https://en.wikipedia.org/wiki/Minimum-shift_keying#Gaussian_minimum-shift_keying
	Modulation_GMSK Modulation = 19
	// Amplitude modulation (generic)
	Modulation_AM Modulation = 20
	// Frequency modulation (generic)
	Modulation_FM Modulation = 21
	// Phase modulation (generic)
	Modulation_PM Modulation = 22
)

var Modulation_name = map[int32]string{
	0:  "FSK",
	1:  "AFSK",
	2:  "BPSK",
	3:  "MFSK",
	4:  "QPSK",
	5:  "PSK8",
	6:  "PSK16",
	7:  "PSK32",
	8:  "PSK64",
	9:  "PSK128",
	10: "PSK256",
	11: "OQPSK",
	12: "QAM8",
	13: "QAM16",
	14: "QAM32",
	15: "QAM64",
	16: "QAM128",
	17: "QAM256",
	18: "MSK",
	19: "GMSK",
	20: "AM",
	21: "FM",
	22: "PM",
}

var Modulation_value = map[string]int32{
	"FSK":    0,
	"AFSK":   1,
	"BPSK":   2,
	"MFSK":   3,
	"QPSK":   4,
	"PSK8":   5,
	"PSK16":  6,
	"PSK32":  7,
	"PSK64":  8,
	"PSK128": 9,
	"PSK256": 10,
	"OQPSK":  11,
	"QAM8":   12,
	"QAM16":  13,
	"QAM32":  14,
	"QAM64":  15,
	"QAM128": 16,
	"QAM256": 17,
	"MSK":    18,
	"GMSK":   19,
	"AM":     20,
	"FM":     21,
	"PM":     22,
}

func (x Modulation) String() string {
	return proto.EnumName(Modulation_name, int32(x))
}

func (Modulation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66895b3707e74834, []int{0}
}

// Line coding applied during modulation. Line coding is the technique for modeling binary 0 and 1
// within a modulated waveform.
type LineCoding int32

const (
	// Non-return-to-zero level.
	// https://en.wikipedia.org/wiki/Non-return-to-zero
	LineCoding_NRZ_L LineCoding = 0
	// Non-return-to-zero mark (i.e., differential encoding).
	// https://en.wikipedia.org/wiki/Non-return-to-zero
	LineCoding_NRZ_M LineCoding = 1
	// Non-return-to-zero space (i.e., non-differential-encoding).
	// https://en.wikipedia.org/wiki/Non-return-to-zero
	LineCoding_NRZ_S LineCoding = 2
	// Return-to-zero. https://en.wikipedia.org/wiki/Return-to-zero
	LineCoding_RZ LineCoding = 3
	// Bipolar return-to-zero level.
	// https://en.wikipedia.org/wiki/Bipolar_encoding
	LineCoding_BP_L LineCoding = 4
	// Bipolar return-to-zero mark (i.e., differential encoding).
	// https://en.wikipedia.org/wiki/Bipolar_encoding
	LineCoding_BP_M LineCoding = 5
	// Bipolar return-to-zero space (i.e., non-differential encoding).
	// https://en.wikipedia.org/wiki/Bipolar_encoding
	LineCoding_BP_S LineCoding = 6
)

var LineCoding_name = map[int32]string{
	0: "NRZ_L",
	1: "NRZ_M",
	2: "NRZ_S",
	3: "RZ",
	4: "BP_L",
	5: "BP_M",
	6: "BP_S",
}

var LineCoding_value = map[string]int32{
	"NRZ_L": 0,
	"NRZ_M": 1,
	"NRZ_S": 2,
	"RZ":    3,
	"BP_L":  4,
	"BP_M":  5,
	"BP_S":  6,
}

func (x LineCoding) String() string {
	return proto.EnumName(LineCoding_name, int32(x))
}

func (LineCoding) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66895b3707e74834, []int{1}
}

// A current status of convolutional coding.
type ConvolutionalCodingStatusMessage_ConvolutionalCodingStatus int32

const (
	// Not locked on.
	ConvolutionalCodingStatusMessage_UNLOCKED ConvolutionalCodingStatusMessage_ConvolutionalCodingStatus = 0
	// Locked onto the in-phase signal.
	ConvolutionalCodingStatusMessage_I_LOCKED ConvolutionalCodingStatusMessage_ConvolutionalCodingStatus = 1
	// Locked onto the quadrature signal.
	ConvolutionalCodingStatusMessage_Q_LOCKED ConvolutionalCodingStatusMessage_ConvolutionalCodingStatus = 2
	// Locked onto both in-phase and quadrature signal.
	ConvolutionalCodingStatusMessage_LOCKED ConvolutionalCodingStatusMessage_ConvolutionalCodingStatus = 3
)

var ConvolutionalCodingStatusMessage_ConvolutionalCodingStatus_name = map[int32]string{
	0: "UNLOCKED",
	1: "I_LOCKED",
	2: "Q_LOCKED",
	3: "LOCKED",
}

var ConvolutionalCodingStatusMessage_ConvolutionalCodingStatus_value = map[string]int32{
	"UNLOCKED": 0,
	"I_LOCKED": 1,
	"Q_LOCKED": 2,
	"LOCKED":   3,
}

func (x ConvolutionalCodingStatusMessage_ConvolutionalCodingStatus) String() string {
	return proto.EnumName(ConvolutionalCodingStatusMessage_ConvolutionalCodingStatus_name, int32(x))
}

func (ConvolutionalCodingStatusMessage_ConvolutionalCodingStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66895b3707e74834, []int{5, 0}
}

// A type of scrambling.
type ScramblingParams_Type int32

const (
	// Additive scrambling.
	ScramblingParams_ADDITIVE ScramblingParams_Type = 0
	// Multiplicative scrambling.
	ScramblingParams_MULTIPLICATIVE ScramblingParams_Type = 1
)

var ScramblingParams_Type_name = map[int32]string{
	0: "ADDITIVE",
	1: "MULTIPLICATIVE",
}

var ScramblingParams_Type_value = map[string]int32{
	"ADDITIVE":       0,
	"MULTIPLICATIVE": 1,
}

func (x ScramblingParams_Type) String() string {
	return proto.EnumName(ScramblingParams_Type_name, int32(x))
}

func (ScramblingParams_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66895b3707e74834, []int{6, 0}
}

// A radio device for RF communication. Usually, a satellite will have one or more radio devices for
// communicating with the ground and a ground station will have one or more radio devices for
// communicating with the satellite. Such devices may not actually correspond to actual hardware
// devices, i.e., in the case of Software Defined Radio (SDR).
type RadioDeviceConfiguration struct {
	// The center frequency of the device, in Hz.
	CenterFrequencyHz uint64 `protobuf:"varint,1,opt,name=center_frequency_hz,json=centerFrequencyHz,proto3" json:"center_frequency_hz,omitempty"`
	// The type of modulation used by this radio device.
	Modulation Modulation `protobuf:"varint,2,opt,name=modulation,proto3,enum=stellarstation.api.v1.radio.Modulation" json:"modulation,omitempty"`
	// The bitrate used during modulation.
	Bitrate uint64 `protobuf:"varint,3,opt,name=bitrate,proto3" json:"bitrate,omitempty"`
	// The protocol used by this device when doing RF communication. If unset, the device is only
	// demodulating / modulating without applying any higher-level communication protocol.
	Protocol             *CommunicationProtocol `protobuf:"bytes,4,opt,name=protocol,proto3" json:"protocol,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *RadioDeviceConfiguration) Reset()         { *m = RadioDeviceConfiguration{} }
func (m *RadioDeviceConfiguration) String() string { return proto.CompactTextString(m) }
func (*RadioDeviceConfiguration) ProtoMessage()    {}
func (*RadioDeviceConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_66895b3707e74834, []int{0}
}

func (m *RadioDeviceConfiguration) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RadioDeviceConfiguration.Unmarshal(m, b)
}
func (m *RadioDeviceConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RadioDeviceConfiguration.Marshal(b, m, deterministic)
}
func (m *RadioDeviceConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RadioDeviceConfiguration.Merge(m, src)
}
func (m *RadioDeviceConfiguration) XXX_Size() int {
	return xxx_messageInfo_RadioDeviceConfiguration.Size(m)
}
func (m *RadioDeviceConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_RadioDeviceConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_RadioDeviceConfiguration proto.InternalMessageInfo

func (m *RadioDeviceConfiguration) GetCenterFrequencyHz() uint64 {
	if m != nil {
		return m.CenterFrequencyHz
	}
	return 0
}

func (m *RadioDeviceConfiguration) GetModulation() Modulation {
	if m != nil {
		return m.Modulation
	}
	return Modulation_FSK
}

func (m *RadioDeviceConfiguration) GetBitrate() uint64 {
	if m != nil {
		return m.Bitrate
	}
	return 0
}

func (m *RadioDeviceConfiguration) GetProtocol() *CommunicationProtocol {
	if m != nil {
		return m.Protocol
	}
	return nil
}

// A communication protocol used with a radio device. These must contain all the parameters
// needed to configure the device for use either in transmission or reception.
type CommunicationProtocol struct {
	// The type of framing used for communication on the device. If `bitstream`, the device is only
	// demodulating / modulating without applying any higher-level framing (i.e., packeting) protocol.
	//
	// Types that are valid to be assigned to Framing:
	//	*CommunicationProtocol_Ax25
	Framing              isCommunicationProtocol_Framing `protobuf_oneof:"Framing"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *CommunicationProtocol) Reset()         { *m = CommunicationProtocol{} }
func (m *CommunicationProtocol) String() string { return proto.CompactTextString(m) }
func (*CommunicationProtocol) ProtoMessage()    {}
func (*CommunicationProtocol) Descriptor() ([]byte, []int) {
	return fileDescriptor_66895b3707e74834, []int{1}
}

func (m *CommunicationProtocol) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CommunicationProtocol.Unmarshal(m, b)
}
func (m *CommunicationProtocol) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CommunicationProtocol.Marshal(b, m, deterministic)
}
func (m *CommunicationProtocol) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommunicationProtocol.Merge(m, src)
}
func (m *CommunicationProtocol) XXX_Size() int {
	return xxx_messageInfo_CommunicationProtocol.Size(m)
}
func (m *CommunicationProtocol) XXX_DiscardUnknown() {
	xxx_messageInfo_CommunicationProtocol.DiscardUnknown(m)
}

var xxx_messageInfo_CommunicationProtocol proto.InternalMessageInfo

type isCommunicationProtocol_Framing interface {
	isCommunicationProtocol_Framing()
}

type CommunicationProtocol_Ax25 struct {
	Ax25 *AX25 `protobuf:"bytes,1,opt,name=ax25,proto3,oneof"`
}

func (*CommunicationProtocol_Ax25) isCommunicationProtocol_Framing() {}

func (m *CommunicationProtocol) GetFraming() isCommunicationProtocol_Framing {
	if m != nil {
		return m.Framing
	}
	return nil
}

func (m *CommunicationProtocol) GetAx25() *AX25 {
	if x, ok := m.GetFraming().(*CommunicationProtocol_Ax25); ok {
		return x.Ax25
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CommunicationProtocol) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CommunicationProtocol_OneofMarshaler, _CommunicationProtocol_OneofUnmarshaler, _CommunicationProtocol_OneofSizer, []interface{}{
		(*CommunicationProtocol_Ax25)(nil),
	}
}

func _CommunicationProtocol_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CommunicationProtocol)
	// Framing
	switch x := m.Framing.(type) {
	case *CommunicationProtocol_Ax25:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ax25); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CommunicationProtocol.Framing has unexpected type %T", x)
	}
	return nil
}

func _CommunicationProtocol_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CommunicationProtocol)
	switch tag {
	case 1: // Framing.ax25
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AX25)
		err := b.DecodeMessage(msg)
		m.Framing = &CommunicationProtocol_Ax25{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CommunicationProtocol_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CommunicationProtocol)
	// Framing
	switch x := m.Framing.(type) {
	case *CommunicationProtocol_Ax25:
		s := proto.Size(x.Ax25)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Communication of a stream of bits with no framing defined.
type BitStream struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BitStream) Reset()         { *m = BitStream{} }
func (m *BitStream) String() string { return proto.CompactTextString(m) }
func (*BitStream) ProtoMessage()    {}
func (*BitStream) Descriptor() ([]byte, []int) {
	return fileDescriptor_66895b3707e74834, []int{2}
}

func (m *BitStream) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BitStream.Unmarshal(m, b)
}
func (m *BitStream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BitStream.Marshal(b, m, deterministic)
}
func (m *BitStream) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BitStream.Merge(m, src)
}
func (m *BitStream) XXX_Size() int {
	return xxx_messageInfo_BitStream.Size(m)
}
func (m *BitStream) XXX_DiscardUnknown() {
	xxx_messageInfo_BitStream.DiscardUnknown(m)
}

var xxx_messageInfo_BitStream proto.InternalMessageInfo

// PACKET communication based on AX.25. https://www.sigidwiki.com/wiki/PACKET.
type AX25 struct {
	// Whether or not G3RUH scrambling is used.
	G3Ruh bool `protobuf:"varint,1,opt,name=g3ruh,proto3" json:"g3ruh,omitempty"`
	// Destination callsign.
	DestinationCallsign string `protobuf:"bytes,2,opt,name=destination_callsign,json=destinationCallsign,proto3" json:"destination_callsign,omitempty"`
	// Destination SSID.
	DestinationSsid uint32 `protobuf:"varint,3,opt,name=destination_ssid,json=destinationSsid,proto3" json:"destination_ssid,omitempty"`
	// Source callsign.
	SourceCallsign string `protobuf:"bytes,4,opt,name=source_callsign,json=sourceCallsign,proto3" json:"source_callsign,omitempty"`
	// Source SSID.
	SourceSsid           uint32   `protobuf:"varint,5,opt,name=source_ssid,json=sourceSsid,proto3" json:"source_ssid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AX25) Reset()         { *m = AX25{} }
func (m *AX25) String() string { return proto.CompactTextString(m) }
func (*AX25) ProtoMessage()    {}
func (*AX25) Descriptor() ([]byte, []int) {
	return fileDescriptor_66895b3707e74834, []int{3}
}

func (m *AX25) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AX25.Unmarshal(m, b)
}
func (m *AX25) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AX25.Marshal(b, m, deterministic)
}
func (m *AX25) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AX25.Merge(m, src)
}
func (m *AX25) XXX_Size() int {
	return xxx_messageInfo_AX25.Size(m)
}
func (m *AX25) XXX_DiscardUnknown() {
	xxx_messageInfo_AX25.DiscardUnknown(m)
}

var xxx_messageInfo_AX25 proto.InternalMessageInfo

func (m *AX25) GetG3Ruh() bool {
	if m != nil {
		return m.G3Ruh
	}
	return false
}

func (m *AX25) GetDestinationCallsign() string {
	if m != nil {
		return m.DestinationCallsign
	}
	return ""
}

func (m *AX25) GetDestinationSsid() uint32 {
	if m != nil {
		return m.DestinationSsid
	}
	return 0
}

func (m *AX25) GetSourceCallsign() string {
	if m != nil {
		return m.SourceCallsign
	}
	return ""
}

func (m *AX25) GetSourceSsid() uint32 {
	if m != nil {
		return m.SourceSsid
	}
	return 0
}

// Parameters for convolutional coding applied to a bitstream.
// https://en.wikipedia.org/wiki/Convolutional_code
type ConvolutionalCodingParams struct {
	// The constraint length, `k`, of the code.
	K uint32 `protobuf:"varint,1,opt,name=k,proto3" json:"k,omitempty"`
	// The inverse of the rate of coding, e.g., if rate is `1 / r`, `inverse_rate` is `r`.
	InverseRate uint32 `protobuf:"varint,2,opt,name=inverse_rate,json=inverseRate,proto3" json:"inverse_rate,omitempty"`
	// The polynomials used for coding. Must have `r` number of elements, where the most significant
	// `k` bits of each element will be used as the polynomial for that index.
	Polynomial           [][]byte `protobuf:"bytes,3,rep,name=polynomial,proto3" json:"polynomial,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConvolutionalCodingParams) Reset()         { *m = ConvolutionalCodingParams{} }
func (m *ConvolutionalCodingParams) String() string { return proto.CompactTextString(m) }
func (*ConvolutionalCodingParams) ProtoMessage()    {}
func (*ConvolutionalCodingParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_66895b3707e74834, []int{4}
}

func (m *ConvolutionalCodingParams) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConvolutionalCodingParams.Unmarshal(m, b)
}
func (m *ConvolutionalCodingParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConvolutionalCodingParams.Marshal(b, m, deterministic)
}
func (m *ConvolutionalCodingParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConvolutionalCodingParams.Merge(m, src)
}
func (m *ConvolutionalCodingParams) XXX_Size() int {
	return xxx_messageInfo_ConvolutionalCodingParams.Size(m)
}
func (m *ConvolutionalCodingParams) XXX_DiscardUnknown() {
	xxx_messageInfo_ConvolutionalCodingParams.DiscardUnknown(m)
}

var xxx_messageInfo_ConvolutionalCodingParams proto.InternalMessageInfo

func (m *ConvolutionalCodingParams) GetK() uint32 {
	if m != nil {
		return m.K
	}
	return 0
}

func (m *ConvolutionalCodingParams) GetInverseRate() uint32 {
	if m != nil {
		return m.InverseRate
	}
	return 0
}

func (m *ConvolutionalCodingParams) GetPolynomial() [][]byte {
	if m != nil {
		return m.Polynomial
	}
	return nil
}

type ConvolutionalCodingStatusMessage struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConvolutionalCodingStatusMessage) Reset()         { *m = ConvolutionalCodingStatusMessage{} }
func (m *ConvolutionalCodingStatusMessage) String() string { return proto.CompactTextString(m) }
func (*ConvolutionalCodingStatusMessage) ProtoMessage()    {}
func (*ConvolutionalCodingStatusMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_66895b3707e74834, []int{5}
}

func (m *ConvolutionalCodingStatusMessage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConvolutionalCodingStatusMessage.Unmarshal(m, b)
}
func (m *ConvolutionalCodingStatusMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConvolutionalCodingStatusMessage.Marshal(b, m, deterministic)
}
func (m *ConvolutionalCodingStatusMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConvolutionalCodingStatusMessage.Merge(m, src)
}
func (m *ConvolutionalCodingStatusMessage) XXX_Size() int {
	return xxx_messageInfo_ConvolutionalCodingStatusMessage.Size(m)
}
func (m *ConvolutionalCodingStatusMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ConvolutionalCodingStatusMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ConvolutionalCodingStatusMessage proto.InternalMessageInfo

// Parameters for scrambling applied to a bitstream.
type ScramblingParams struct {
	// The type of scrambling.
	Type ScramblingParams_Type `protobuf:"varint,1,opt,name=type,proto3,enum=stellarstation.api.v1.radio.ScramblingParams_Type" json:"type,omitempty"`
	// The length of the shift register, in bits.
	NumBits uint32 `protobuf:"varint,2,opt,name=num_bits,json=numBits,proto3" json:"num_bits,omitempty"`
	// The polynomial mask for the shift register. The most significant `num_bits` bits of `mask` will
	// be used.
	Mask []byte `protobuf:"bytes,3,opt,name=mask,proto3" json:"mask,omitempty"`
	// The initial contents of the shift register. The most significant `num_bits` bits of `mask` will
	// be used.
	Seed                 []byte   `protobuf:"bytes,4,opt,name=seed,proto3" json:"seed,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ScramblingParams) Reset()         { *m = ScramblingParams{} }
func (m *ScramblingParams) String() string { return proto.CompactTextString(m) }
func (*ScramblingParams) ProtoMessage()    {}
func (*ScramblingParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_66895b3707e74834, []int{6}
}

func (m *ScramblingParams) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ScramblingParams.Unmarshal(m, b)
}
func (m *ScramblingParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ScramblingParams.Marshal(b, m, deterministic)
}
func (m *ScramblingParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScramblingParams.Merge(m, src)
}
func (m *ScramblingParams) XXX_Size() int {
	return xxx_messageInfo_ScramblingParams.Size(m)
}
func (m *ScramblingParams) XXX_DiscardUnknown() {
	xxx_messageInfo_ScramblingParams.DiscardUnknown(m)
}

var xxx_messageInfo_ScramblingParams proto.InternalMessageInfo

func (m *ScramblingParams) GetType() ScramblingParams_Type {
	if m != nil {
		return m.Type
	}
	return ScramblingParams_ADDITIVE
}

func (m *ScramblingParams) GetNumBits() uint32 {
	if m != nil {
		return m.NumBits
	}
	return 0
}

func (m *ScramblingParams) GetMask() []byte {
	if m != nil {
		return m.Mask
	}
	return nil
}

func (m *ScramblingParams) GetSeed() []byte {
	if m != nil {
		return m.Seed
	}
	return nil
}

func init() {
	proto.RegisterEnum("stellarstation.api.v1.radio.Modulation", Modulation_name, Modulation_value)
	proto.RegisterEnum("stellarstation.api.v1.radio.LineCoding", LineCoding_name, LineCoding_value)
	proto.RegisterEnum("stellarstation.api.v1.radio.ConvolutionalCodingStatusMessage_ConvolutionalCodingStatus", ConvolutionalCodingStatusMessage_ConvolutionalCodingStatus_name, ConvolutionalCodingStatusMessage_ConvolutionalCodingStatus_value)
	proto.RegisterEnum("stellarstation.api.v1.radio.ScramblingParams_Type", ScramblingParams_Type_name, ScramblingParams_Type_value)
	proto.RegisterType((*RadioDeviceConfiguration)(nil), "stellarstation.api.v1.radio.RadioDeviceConfiguration")
	proto.RegisterType((*CommunicationProtocol)(nil), "stellarstation.api.v1.radio.CommunicationProtocol")
	proto.RegisterType((*BitStream)(nil), "stellarstation.api.v1.radio.BitStream")
	proto.RegisterType((*AX25)(nil), "stellarstation.api.v1.radio.AX25")
	proto.RegisterType((*ConvolutionalCodingParams)(nil), "stellarstation.api.v1.radio.ConvolutionalCodingParams")
	proto.RegisterType((*ConvolutionalCodingStatusMessage)(nil), "stellarstation.api.v1.radio.ConvolutionalCodingStatusMessage")
	proto.RegisterType((*ScramblingParams)(nil), "stellarstation.api.v1.radio.ScramblingParams")
}

func init() {
	proto.RegisterFile("stellarstation/api/v1/radio/radio.proto", fileDescriptor_66895b3707e74834)
}

var fileDescriptor_66895b3707e74834 = []byte{
	// 818 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x54, 0x5f, 0x6f, 0xe2, 0xc6,
	0x17, 0xc5, 0x60, 0xfe, 0x5d, 0x08, 0x99, 0x9d, 0x64, 0x7f, 0x62, 0xf5, 0x93, 0xba, 0xac, 0x5f,
	0x42, 0x57, 0xaa, 0x11, 0xce, 0x86, 0xf2, 0x0a, 0x64, 0xd9, 0x45, 0xe0, 0xac, 0x63, 0x67, 0xab,
	0x2a, 0x7d, 0xb0, 0x06, 0x33, 0x21, 0xa3, 0xd8, 0x1e, 0xea, 0x3f, 0xa8, 0xd9, 0xcf, 0x57, 0xa9,
	0x9f, 0xa9, 0x0f, 0x95, 0xaa, 0x19, 0x9b, 0x84, 0x56, 0x11, 0x7d, 0xc1, 0xe7, 0x9e, 0x7b, 0xee,
	0xb9, 0xdc, 0xb9, 0xf6, 0xc0, 0x59, 0x9c, 0x50, 0xdf, 0x27, 0x51, 0x9c, 0x90, 0x84, 0xf1, 0xb0,
	0x47, 0x36, 0xac, 0xb7, 0xed, 0xf7, 0x22, 0xb2, 0x62, 0x3c, 0xfb, 0xd5, 0x37, 0x11, 0x4f, 0x38,
	0xfe, 0xff, 0x3f, 0x85, 0x3a, 0xd9, 0x30, 0x7d, 0xdb, 0xd7, 0xa5, 0x44, 0xfb, 0x4b, 0x81, 0xb6,
	0x2d, 0xd0, 0x25, 0xdd, 0x32, 0x8f, 0x4e, 0x78, 0x78, 0xc7, 0xd6, 0x69, 0x24, 0x95, 0x58, 0x87,
	0x13, 0x8f, 0x86, 0x09, 0x8d, 0xdc, 0xbb, 0x88, 0xfe, 0x9a, 0xd2, 0xd0, 0x7b, 0x74, 0xef, 0xbf,
	0xb5, 0x95, 0x8e, 0xd2, 0x55, 0xed, 0x57, 0x59, 0x6a, 0xba, 0xcb, 0x7c, 0xfe, 0x86, 0x3f, 0x01,
	0x04, 0x7c, 0x95, 0xfa, 0xb2, 0xba, 0x5d, 0xec, 0x28, 0xdd, 0x96, 0x71, 0xa6, 0x1f, 0x68, 0xaf,
	0x9b, 0x4f, 0x72, 0x7b, 0xaf, 0x14, 0xb7, 0xa1, 0xba, 0x64, 0x49, 0x44, 0x12, 0xda, 0x2e, 0xc9,
	0x66, 0xbb, 0x10, 0x5f, 0x41, 0x4d, 0x4e, 0xe5, 0x71, 0xbf, 0xad, 0x76, 0x94, 0x6e, 0xc3, 0x30,
	0x0e, 0x36, 0x98, 0xf0, 0x20, 0x48, 0x43, 0xe6, 0xc9, 0x94, 0x95, 0x57, 0xda, 0x4f, 0x1e, 0xda,
	0x2f, 0xf0, 0xfa, 0x45, 0x09, 0xfe, 0x11, 0x54, 0xf2, 0x9b, 0x71, 0x21, 0x87, 0x6d, 0x18, 0xef,
	0x0e, 0x36, 0x19, 0xfd, 0x6c, 0x5c, 0x7c, 0x2e, 0xd8, 0xb2, 0x60, 0x5c, 0x87, 0xea, 0x34, 0x22,
	0x01, 0x0b, 0xd7, 0x5a, 0x03, 0xea, 0x63, 0x96, 0x38, 0x49, 0x44, 0x49, 0xa0, 0xfd, 0xae, 0x80,
	0x2a, 0x84, 0xf8, 0x14, 0xca, 0xeb, 0xf3, 0x28, 0xbd, 0x97, 0xd6, 0x35, 0x3b, 0x0b, 0x70, 0x1f,
	0x4e, 0x57, 0x34, 0x4e, 0x58, 0x28, 0xfd, 0x5d, 0x8f, 0xf8, 0x7e, 0xcc, 0xd6, 0xd9, 0x29, 0xd6,
	0xed, 0x93, 0xbd, 0xdc, 0x24, 0x4f, 0xe1, 0xef, 0x01, 0xed, 0x97, 0xc4, 0x31, 0x5b, 0xc9, 0xe3,
	0x3a, 0xb2, 0x8f, 0xf7, 0x78, 0x27, 0x66, 0x2b, 0x7c, 0x06, 0xc7, 0x31, 0x4f, 0x23, 0x8f, 0x3e,
	0x1b, 0xab, 0xd2, 0xb8, 0x95, 0xd1, 0x4f, 0x9e, 0x6f, 0xa1, 0x91, 0x0b, 0xa5, 0x5d, 0x59, 0xda,
	0x41, 0x46, 0x09, 0x27, 0xcd, 0x87, 0x37, 0x13, 0x1e, 0x6e, 0xb9, 0x9f, 0x0a, 0x73, 0xe2, 0x4f,
	0xf8, 0x8a, 0x85, 0x6b, 0x8b, 0x44, 0x24, 0x88, 0x71, 0x13, 0x94, 0x07, 0x39, 0xd6, 0x91, 0xad,
	0x3c, 0xe0, 0x77, 0xd0, 0x64, 0xe1, 0x96, 0x46, 0x31, 0x75, 0xe5, 0x2a, 0x8b, 0x32, 0xd1, 0xc8,
	0x39, 0x5b, 0xac, 0xf3, 0x3b, 0x80, 0x0d, 0xf7, 0x1f, 0x43, 0x1e, 0x30, 0xe2, 0xb7, 0x4b, 0x9d,
	0x52, 0xb7, 0x69, 0xef, 0x31, 0x5a, 0x0a, 0x9d, 0x17, 0xba, 0x39, 0x09, 0x49, 0xd2, 0xd8, 0xa4,
	0x71, 0x4c, 0xd6, 0x54, 0xbb, 0x7e, 0xf1, 0x1f, 0x65, 0x1a, 0xdc, 0x84, 0xda, 0xd7, 0xab, 0xc5,
	0x97, 0xc9, 0xfc, 0xe3, 0x25, 0x2a, 0x88, 0x68, 0xe6, 0xe6, 0x91, 0x22, 0xa2, 0xeb, 0x5d, 0x54,
	0xc4, 0x00, 0x95, 0x1c, 0x97, 0xb4, 0x3f, 0x14, 0x40, 0x8e, 0x17, 0x91, 0x60, 0xe9, 0x3f, 0x0f,
	0x37, 0x05, 0x35, 0x79, 0xdc, 0x50, 0x39, 0x5f, 0xeb, 0x3f, 0x5e, 0xbb, 0x7f, 0x17, 0xeb, 0x37,
	0x8f, 0x1b, 0x6a, 0xcb, 0x7a, 0xfc, 0x06, 0x6a, 0x61, 0x1a, 0xb8, 0x4b, 0x96, 0xc4, 0xf9, 0x91,
	0x54, 0xc3, 0x34, 0x18, 0xb3, 0x24, 0xc6, 0x18, 0xd4, 0x80, 0xc4, 0x0f, 0x72, 0x8b, 0x4d, 0x5b,
	0x62, 0xc1, 0xc5, 0x94, 0xae, 0xe4, 0xbe, 0x9a, 0xb6, 0xc4, 0x5a, 0x17, 0x54, 0x61, 0x28, 0x26,
	0x18, 0x5d, 0x5e, 0xce, 0x6e, 0x66, 0x3f, 0x7d, 0x44, 0x05, 0x8c, 0xa1, 0x65, 0x7e, 0x5d, 0xdc,
	0xcc, 0xac, 0xc5, 0x6c, 0x32, 0x92, 0x9c, 0xf2, 0xfe, 0x4f, 0x05, 0xe0, 0xf9, 0x23, 0xc3, 0x55,
	0x28, 0x4d, 0x9d, 0x39, 0x2a, 0xe0, 0x1a, 0xa8, 0x23, 0x81, 0x14, 0x81, 0xc6, 0x96, 0x33, 0x47,
	0x45, 0x81, 0x4c, 0xc1, 0x95, 0x04, 0xba, 0x16, 0x9c, 0x2a, 0x90, 0xe5, 0xcc, 0x87, 0xa8, 0x8c,
	0xeb, 0x50, 0xb6, 0x9c, 0x79, 0x7f, 0x80, 0x2a, 0x39, 0x3c, 0x37, 0x50, 0x35, 0x87, 0x83, 0x0f,
	0xa8, 0x26, 0x0e, 0x50, 0x08, 0x8c, 0x21, 0xaa, 0xe7, 0xd8, 0xb8, 0x18, 0x20, 0x10, 0x92, 0x2f,
	0xd2, 0xad, 0x21, 0x7d, 0x47, 0xe6, 0x10, 0x35, 0x05, 0x79, 0x3d, 0x32, 0xfb, 0x03, 0x74, 0x94,
	0xc3, 0x73, 0x03, 0xb5, 0x72, 0x38, 0xf8, 0x80, 0x8e, 0x85, 0x83, 0x10, 0x18, 0x43, 0x84, 0x72,
	0x2c, 0xdc, 0x5e, 0x89, 0x09, 0x4c, 0x67, 0x8e, 0xb0, 0xf0, 0xfa, 0x24, 0xd0, 0x09, 0xae, 0x40,
	0x71, 0x64, 0xa2, 0x53, 0xf1, 0x9c, 0x9a, 0xe8, 0xb5, 0x78, 0x5a, 0x26, 0xfa, 0xdf, 0x7b, 0x07,
	0x60, 0xc1, 0x42, 0x9a, 0xbd, 0x0f, 0xc2, 0xfb, 0xca, 0xbe, 0x75, 0x17, 0xa8, 0xb0, 0x83, 0x26,
	0x52, 0x76, 0xd0, 0x41, 0x45, 0x51, 0x66, 0xdf, 0x66, 0xc3, 0x8f, 0x2d, 0x77, 0x91, 0x0d, 0x3f,
	0xb6, 0x5c, 0x13, 0x95, 0x73, 0xe4, 0xa0, 0xca, 0x98, 0xc1, 0x5b, 0x8f, 0x07, 0x87, 0x96, 0x3f,
	0x06, 0x79, 0xa1, 0xca, 0x9b, 0xc4, 0x52, 0x6e, 0x87, 0x6b, 0x96, 0xdc, 0xa7, 0x4b, 0xdd, 0xe3,
	0x41, 0x8f, 0x85, 0x77, 0x3c, 0xaf, 0x64, 0xa1, 0xd7, 0x5b, 0xf3, 0x1f, 0x0e, 0x5c, 0xe2, 0xcb,
	0x8a, 0xbc, 0xa5, 0xce, 0xff, 0x0e, 0x00, 0x00, 0xff, 0xff, 0x69, 0x25, 0x3b, 0x0f, 0xea, 0x05,
	0x00, 0x00,
}
